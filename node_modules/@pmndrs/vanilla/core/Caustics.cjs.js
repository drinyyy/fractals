"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),r=require("./shaderMaterial.cjs.js"),n=require("three/examples/jsm/postprocessing/Pass.js"),t=require("./useFBO.cjs.js");function o(e){if(e&&e.__esModule)return e;var r=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var t=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(r,n,t.get?t:{enumerable:!0,get:function(){return e[n]}})}})),r.default=e,Object.freeze(r)}var i=o(e);const a=e=>null==e?void 0:e.isVector3;function l(e=i.FrontSide){const r={value:new i.Matrix4};return Object.assign(new i.MeshNormalMaterial({side:e}),{viewMatrix:r,onBeforeCompile:e=>{e.uniforms.viewMatrix=r,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const s=r.shaderMaterial({causticsTexture:null,causticsTextureB:null,color:new i.Color,lightProjMatrix:new i.Matrix4,lightViewMatrix:new i.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }",`varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <${parseInt(i.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`),c=r.shaderMaterial({cameraMatrixWorld:new i.Matrix4,cameraProjectionMatrixInv:new i.Matrix4,normalTexture:null,depthTexture:null,lightDir:new i.Vector3(0,1,0),lightPlaneNormal:new i.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new i.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),u={depth:!0,minFilter:i.LinearFilter,magFilter:i.LinearFilter,type:i.UnsignedByteType},d={minFilter:i.LinearMipmapLinearFilter,magFilter:i.LinearFilter,type:i.FloatType,generateMipmaps:!0};function m(e){const r=l(),t=l(i.BackSide),o=new c,s=new n.FullScreenQuad(o);let u=0;const d=new i.Vector3,m=new i.Frustum,p=new i.Matrix4,v=new i.Plane,x=new i.Vector3,f=new i.Vector3,g=new i.Box3,h=new i.Vector3,P=[],y=[],w=[],M=[],D=new i.Vector3;for(let e=0;e<8;e++)P.push(new i.Vector3),y.push(new i.Vector3),w.push(new i.Vector3),M.push(new i.Vector3);return function(n){const{params:i,helper:l,camera:c,plane:T,normalTarget:S,normalTargetB:b,causticsTarget:F,causticsTargetB:j,scene:z,group:O}=e();if(i.frames===1/0||i.frames&&u++<i.frames){var R;a(i.lightSource)?x.copy(i.lightSource).normalize():i.lightSource&&x.copy(O.worldToLocal(i.lightSource.getWorldPosition(d)).normalize()),f.copy(x).multiplyScalar(-1),null==(R=z.parent)||R.matrixWorld.identity(),g.setFromObject(z,!0),P[0].set(g.min.x,g.min.y,g.min.z),P[1].set(g.min.x,g.min.y,g.max.z),P[2].set(g.min.x,g.max.y,g.min.z),P[3].set(g.min.x,g.max.y,g.max.z),P[4].set(g.max.x,g.min.y,g.min.z),P[5].set(g.max.x,g.min.y,g.max.z),P[6].set(g.max.x,g.max.y,g.min.z),P[7].set(g.max.x,g.max.y,g.max.z);for(let e=0;e<8;e++)y[e].copy(P[e]);g.getCenter(h),P.map((e=>e.sub(h)));const e=v.set(f,0);P.map(((r,n)=>e.projectPoint(r,w[n])));const u=w.reduce(((e,r)=>e.add(r)),d.set(0,0,0)).divideScalar(w.length),W=w.map((e=>e.distanceTo(u))).reduce(((e,r)=>Math.max(e,r))),I=P.map((e=>e.dot(x))).reduce(((e,r)=>Math.max(e,r)));c.position.copy(D.copy(x).multiplyScalar(I).add(h)),c.lookAt(z.localToWorld(h));const C=p.lookAt(c.position,h,d.set(0,1,0));if(c.left=-W,c.right=W,c.top=W,c.bottom=-W,i.near&&(c.near=i.near),i.far)c.far=i.far;else{const e=d.set(0,W,0).applyMatrix4(C),r=(c.position.y+e.y)/x.y;c.far=r}c.updateProjectionMatrix(),c.updateMatrixWorld();const _=y.map(((e,r)=>e.add(M[r].copy(x).multiplyScalar(-e.y/x.y)))),B=_.reduce(((e,r)=>e.add(r)),d.set(0,0,0)).divideScalar(_.length),V=2*_.map((e=>Math.hypot(e.x-B.x,e.z-B.z))).reduce(((e,r)=>Math.max(e,r)));T.scale.setScalar(V),T.position.copy(B),null!=l&&l.parent&&l.update(),t.viewMatrix.value=r.viewMatrix.value=c.matrixWorldInverse;const k=m.setFromProjectionMatrix(p.multiplyMatrices(c.projectionMatrix,c.matrixWorldInverse)).planes[4];o.cameraMatrixWorld=c.matrixWorld,o.cameraProjectionMatrixInv=c.projectionMatrixInverse,o.lightDir=f,o.lightPlaneNormal=k.normal,o.lightPlaneConstant=k.constant,o.near=c.near,o.far=c.far,i.resolution&&(o.resolution=i.resolution),o.size=W,i.intensity&&(o.intensity=i.intensity),i.worldRadius&&(o.worldRadius=i.worldRadius),z.visible=!0,n.setRenderTarget(S),n.clear(),z.overrideMaterial=r,n.render(z,c),n.setRenderTarget(b),n.clear(),i.backside&&(z.overrideMaterial=t,n.render(z,c)),z.overrideMaterial=null,i.ior&&(o.ior=i.ior),T.material.lightProjMatrix=c.projectionMatrix,T.material.lightViewMatrix=c.matrixWorldInverse,o.normalTexture=S.texture,o.depthTexture=S.depthTexture,n.setRenderTarget(F),n.clear(),s.render(n),i.backsideIOR&&(o.ior=i.backsideIOR),o.normalTexture=b.texture,o.depthTexture=b.depthTexture,n.setRenderTarget(j),n.clear(),i.backside&&s.render(n),n.setRenderTarget(null),i.causticsOnly&&(z.visible=!1)}}}exports.Caustics=(e,{frames:r=1,causticsOnly:n=!1,ior:o=1.1,backside:a=!1,backsideIOR:l=1.1,worldRadius:c=.3125,color:p=new i.Color("white"),intensity:v=.05,resolution:x=2024,lightSource:f=new i.Vector3(1,1,1),near:g=.1,far:h=0}={})=>{const P={frames:r,ior:o,color:p,causticsOnly:n,backside:a,backsideIOR:l,worldRadius:c,intensity:v,resolution:x,lightSource:f,near:g,far:h},y=new i.Group;y.name="caustics_group";const w=new i.OrthographicCamera,M=new i.Scene;M.name="caustics_scene";const D=e,T=new i.CameraHelper(w);T.name="caustics_helper";const S=P.resolution,b=t.useFBO(S,S,u),F=t.useFBO(S,S,u),j=t.useFBO(S,S,d),z=t.useFBO(S,S,d),O=new i.Mesh(new i.PlaneGeometry(1,1),new s({transparent:!0,color:P.color,causticsTexture:j.texture,causticsTextureB:z.texture,blending:i.CustomBlending,blendSrc:i.OneFactor,blendDst:i.SrcAlphaFactor,depthWrite:!1}));O.name="caustics_plane",O.rotation.x=-Math.PI/2,O.renderOrder=2,y.add(M,O),y.updateWorldMatrix(!1,!0);const R=m((()=>({params:P,scene:M,group:y,camera:w,plane:O,normalTarget:b,normalTargetB:F,causticsTarget:j,causticsTargetB:z,helper:T})));return{scene:M,group:y,helper:T,params:P,update:R.bind({},D),normalTarget:b,normalTargetB:F,causticsTarget:j,causticsTargetB:z}},exports.CausticsMaterial=c,exports.CausticsProjectionMaterial=s,exports.createCausticsUpdate=m;
