"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three"),e=require("../helpers/deprecated.cjs.js");const o=new t.Matrix4,r=new t.Vector3,s=new t.Quaternion,n=new t.Vector3,a=new t.Quaternion,i=new t.Vector3,l=e=>class extends e{constructor(){super();const e=parseInt(t.REVISION.replace(/\D+/g,""))>=154?"opaque_fragment":"output_fragment";this.onBeforeCompile=t=>{t.vertexShader="attribute float cloudOpacity;\n               varying float vOpacity;\n              "+t.vertexShader.replace("#include <fog_vertex>","#include <fog_vertex>\n                 vOpacity = cloudOpacity;\n                "),t.fragmentShader="varying float vOpacity;\n              "+t.fragmentShader.replace(`#include <${e}>`,`#include <${e}>\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\n                `)}}};class c extends t.Group{constructor({limit:c=200,range:d,material:u=t.MeshLambertMaterial,texture:h,frustumCulled:p=!0}={}){super(),this.name="Clouds",this.ref=this;const m=new t.PlaneGeometry(1,1),f=new Float32Array(Array.from({length:c},(()=>1))),g=new Float32Array(Array.from({length:c},(()=>[1,1,1])).flat()),y=new t.InstancedBufferAttribute(f,1);y.setUsage(t.DynamicDrawUsage),m.setAttribute("cloudOpacity",y);const x=new(l(u));x.map=h,x.transparent=!0,x.depthWrite=!1,x.needsUpdate=!0,this.cloudMaterial=x,this.instance=new t.InstancedMesh(m,x,c);const w=this.instance;w.matrixAutoUpdate=!1,w.frustumCulled=p,w.instanceColor=new t.InstancedBufferAttribute(g,3),w.instanceColor.setUsage(t.DynamicDrawUsage),this.add(w);const v=[],A=()=>{const t=v.length;let e=0;for(let t=0;t<this.ref.children.length;t++){const o=this.ref.children[t];o.cloudStateArray&&(e+=o.cloudStateArray.length)}if(t===e)return v;v.length=0;for(let t=0;t<this.ref.children.length;t++){const e=this.ref.children[t];e.cloudStateArray&&v.push(...e.cloudStateArray)}return b(),v},b=()=>{const t=Math.min(c,void 0!==d?d:c,v.length);w.count=t,e.setUpdateRange(w.instanceMatrix,{offset:0,count:16*t}),w.instanceColor&&e.setUpdateRange(w.instanceColor,{offset:0,count:3*t}),e.setUpdateRange(w.geometry.attributes.cloudOpacity,{offset:0,count:t})};let M,C=0,S=0;const U=new t.Quaternion,O=new t.Vector3(0,0,1),V=new t.Vector3;this.update=(t,e,l)=>{C=e,o.copy(w.matrixWorld).invert(),t.matrixWorld.decompose(n,a,i);const c=A();for(S=0;S<c.length;S++)M=c[S],M.ref.matrixWorld.decompose(r,s,i),r.add(V.copy(M.position).applyQuaternion(s).multiply(i)),s.copy(a).multiply(U.setFromAxisAngle(O,M.rotation+=l*M.rotationFactor)),i.multiplyScalar(M.volume+(1+Math.sin(C*M.density*M.speed))/2*M.growth),M.matrix.compose(r,s,i).premultiply(o),M.dist=r.distanceTo(n);for(c.sort(((t,e)=>e.dist-t.dist)),S=0;S<c.length;S++)M=c[S],f[S]=M.opacity*(M.dist<M.fade-1?M.dist/M.fade:1),w.setMatrixAt(S,M.matrix),w.setColorAt(S,M.color);w.geometry.attributes.cloudOpacity.needsUpdate=!0,w.instanceMatrix.needsUpdate=!0,w.instanceColor&&(w.instanceColor.needsUpdate=!0)}}}let d=0;class u extends t.Group{constructor({opacity:e=1,speed:o=0,bounds:r=(new t.Vector3).fromArray([5,1,1]),segments:s=20,color:n=new t.Color("#ffffff"),fade:a=10,volume:i=6,smallestVolume:l=.25,distribute:c=null,growth:u=4,concentrate:h="inside",seed:p=Math.random()}={}){super(),this.name="cloud_"+d++,this.seed=p,this.segments=s,this.bounds=r,this.concentrate=h,this.volume=i,this.smallestVolume=l,this.distribute=c,this.growth=u,this.speed=o,this.fade=a,this.opacity=e,this.color=n,this.ref=this,this.cloudStateArray=[],this.updateCloud()}updateCloudStateArray(){if(this.cloudStateArray.length===this.segments)return;const{segments:e,uuid:o}=this;if(this.cloudStateArray.length>this.segments)this.cloudStateArray.splice(0,this.cloudStateArray.length-this.segments);else for(let r=this.cloudStateArray.length;r<e;r++)this.cloudStateArray.push({segments:e,bounds:new t.Vector3(1,1,1),position:new t.Vector3,uuid:o,index:r,ref:this,dist:0,matrix:new t.Matrix4,volume:0,length:0,speed:0,growth:0,opacity:1,fade:0,density:0,rotation:r*(Math.PI/e),rotationFactor:0,color:new t.Color})}updateCloud(){const{volume:t,color:e,speed:o,growth:r,opacity:s,fade:n,bounds:a,seed:i,cloudStateArray:l,distribute:c,segments:d,concentrate:u,smallestVolume:h}=this;this.updateCloudStateArray();let p=0;function m(){const t=1e4*Math.sin(i+p);return p++,t-Math.floor(t)}l.forEach(((i,l)=>{i.segments=d,i.volume=t,i.color=e,i.speed=o,i.growth=r,i.opacity=s,i.fade=n,i.bounds.copy(a),i.density=Math.max(.5,m()),i.rotationFactor=Math.max(.2,.5*m())*o;const p=null==c?void 0:c(i,l);var f;(p||d>1)&&i.position.copy(i.bounds).multiply(null!==(f=null==p?void 0:p.point)&&void 0!==f?f:{x:2*m()-1,y:2*m()-1,z:2*m()-1});const g=Math.abs(i.position.x),y=Math.abs(i.position.y),x=Math.abs(i.position.z),w=Math.max(g,y,x);i.length=1,g===w&&(i.length-=g/i.bounds.x),y===w&&(i.length-=y/i.bounds.y),x===w&&(i.length-=x/i.bounds.z),i.volume=(void 0!==(null==p?void 0:p.volume)?p.volume:Math.max(Math.max(0,h),"random"===u?m():"inside"===u?i.length:1-i.length))*t}))}}exports.CLOUD_URL="https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",exports.Cloud=u,exports.Clouds=c;
