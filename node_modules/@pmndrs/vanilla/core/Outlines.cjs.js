"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./shaderMaterial.cjs.js"),n=require("three"),t=require("three/examples/jsm/utils/BufferGeometryUtils.js");function r(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var o=r(n);const i=e.shaderMaterial({screenspace:!1,color:new o.Color("black"),opacity:1,thickness:.05,size:new o.Vector2},"\n   #include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform float screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n\t   #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace == 0.0) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }",`\n   uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(o.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);exports.Outlines=function({color:e=new o.Color("black"),opacity:n=1,transparent:r=!1,screenspace:a=!1,toneMapped:c=!0,polygonOffset:s=!1,polygonOffsetFactor:l=0,renderOrder:p=0,thickness:d=.05,angle:f=Math.PI,gl:u}){const m=new o.Group;let g={color:e,opacity:n,transparent:r,screenspace:a,toneMapped:c,polygonOffset:s,polygonOffsetFactor:l,renderOrder:p,thickness:d,angle:f};function v(e){const n=m.parent;if(m.clear(),n&&n.geometry){let r;const a=new i({side:o.BackSide});n.skeleton?(r=new o.SkinnedMesh,r.material=a,r.bind(n.skeleton,n.bindMatrix),m.add(r)):n.isInstancedMesh?(r=new o.InstancedMesh(n.geometry,a,n.count),r.instanceMatrix=n.instanceMatrix,m.add(r)):(r=new o.Mesh,r.material=a,m.add(r)),r.geometry=e?t.toCreasedNormals(n.geometry,e):n.geometry}}function x(e){g={...g,...e};const n=m.children[0];if(n){const{transparent:e,thickness:t,color:r,opacity:i,screenspace:a,toneMapped:c,polygonOffset:s,polygonOffsetFactor:l,renderOrder:p}=g,d=new o.Vector2;!u&&g.screenspace&&console.warn('Outlines: "screenspace" requires a WebGLRenderer instance to calculate the outline size'),u&&u.getSize(d),Object.assign(n.material,{transparent:e,thickness:t,color:r,opacity:i,size:d,screenspace:a,toneMapped:c,polygonOffset:s,polygonOffsetFactor:l}),void 0!==p&&(n.renderOrder=p)}}return{group:m,updateProps(e){var n;const t=null!==(n=e.angle)&&void 0!==n?n:g.angle;t!==g.angle&&v(t),x(e)},generate(){v(g.angle),x(g)}}};
